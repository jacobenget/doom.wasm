#include <assert.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <errno.h>
#include <SDL.h>

#include <doom_imports.h>
#include <doom_utils.h>

// Associate some appropriate SDL_KeyCode values directly with enum DoomKeyLabel
// values
static struct {
  SDL_KeyCode sdlKeyCode;
  enum DoomKeyLabel label;
} doomKeyLabelForSdlKeyCodes[] = {
    {SDLK_LEFT, KEY_LEFTARROW},
    {SDLK_RIGHT, KEY_RIGHTARROW},
    {SDLK_UP, KEY_UPARROW},
    {SDLK_DOWN, KEY_DOWNARROW},
    {SDLK_COMMA, KEY_STRAFE_L},
    {SDLK_PERIOD, KEY_STRAFE_R},
    {SDLK_LCTRL, KEY_FIRE},
    {SDLK_RCTRL, KEY_FIRE},
    {SDLK_SPACE, KEY_USE},
    {SDLK_LSHIFT, KEY_SHIFT},
    {SDLK_RSHIFT, KEY_SHIFT},
    {SDLK_TAB, KEY_TAB},
    {SDLK_ESCAPE, KEY_ESCAPE},
    {SDLK_RETURN, KEY_ENTER},
    {SDLK_BACKSPACE, KEY_BACKSPACE},
    {SDLK_LALT, KEY_ALT},
    {SDLK_RALT, KEY_ALT},
};

/*
 * Returns a non-NULL error if there was an issue when running the game,
 * otherwise NULL is returned on success.
 */
doom_module_error_t *run_game(doom_module_context_t *context) {
  doom_module_error_t *error = initGame(context);

  while (!error) {
    error = tickGame(context);

    SDL_Event e;
    while (!error && SDL_PollEvent(&e)) {
      if (e.type == SDL_QUIT) {
        atexit(SDL_Quit);
        return NULL; // Game ran to successful completion!
      } else if (e.type == SDL_KEYDOWN || e.type == SDL_KEYUP) {
        // By default the doom key for a given keyboard key is the unicode value
        // representing the unmodified character that would be generated by
        // pressing the key
        int32_t doomKey = e.key.keysym.sym;

        // Some SDL_Keycode values map, semantically, to values of enum
        // DoomKeyLabel though (e.g. SDLK_SPACE maps to KEY_USE), and we'll
        // check for such a case here.
        for (int i = 0; i < ARRAY_LENGTH(doomKeyLabelForSdlKeyCodes); i++) {
          if (doomKeyLabelForSdlKeyCodes[i].sdlKeyCode == e.key.keysym.sym) {
            // In the case that we find an enum DoomKeyLabel value associated
            // with the pressed/unpressed SDL_Keycode value, the doom key value
            // we should use will be retrieved by calling `doomKeyForLabel`
            error = doomKeyForLabel(
                context, doomKeyLabelForSdlKeyCodes[i].label, &doomKey);
            break;
          }
        }

        if (!error && 0 <= doomKey && doomKey <= 255) {
          if (e.type == SDL_KEYDOWN) {
            error = reportKeyDown(context, doomKey);
          } else {
            error = reportKeyUp(context, doomKey);
          }
        }
      }
    }
  }

  return error;
}

#define SAVE_GAME_FOLDER "./.savegame"

// Caller receives ownership of the returned FILE, and is expected to call
// `fclose` on it.
//
// Returns NULL in the case of failure to open the save game file associated
// with this `gameSaveId`.
static FILE *fopen_saveGame(int32_t gameSaveId, const char *mode) {
  char *pathToSaveGameFile =
      sprintf_with_malloc(SAVE_GAME_FOLDER "/doomsav%d.dsg", gameSaveId);
  FILE *result = fopen(pathToSaveGameFile, mode);
  free(pathToSaveGameFile);
  return result;
}

// Utility to return 'true' in the case that this code is running on a
// little-endian platform, and `false` otherwise.
static bool running_on_little_endian() {
  volatile union {
    uint16_t i;
    uint8_t c[sizeof(uint16_t)];
  } u;

  u.i = 1;
  return u.c[0] == 1;
}

////////////////////////////////////////////////////////////
// Implementation of all Doom WebAssembly imports
////////////////////////////////////////////////////////////

// State shared between functions
//
// Note: due to use of this shared global state, these functions, imported into
// a Doom WebAssembly module, can't currently be imported by more than one Doom
// WebAssembly module.
//
// Removing this restriction shouldn't be that difficult (implementation sketch:
// users of `doom_module_context_t` are given the new ability to associate
// (attach and retrieve) their own custom state to an instance of the Doom
// WebAssembly module) but this isn't being addressed now.
static SDL_Window *window;
static SDL_Texture *texture;

/*
 * Perform one-time initialization upon Doom first starting up
 *
 * args:
 *  context:
 *    - allows interaction with Doom WebAssembly module exports
 *  width:
 *    - width, in pixels, of the frame buffer that will be passed to
 *      `ui_drawFrame`
 *  height:
 *    - height, in pixels, of the frame buffer that will be passed to
 *      `ui_drawFrame`
 *
 * Implements Doom import: function loading.onGameInit(i32, i32) -> ()
 */
void loading_onGameInit(doom_module_context_t *context, int32_t width,
                        int32_t height) {
  // This code currently depends upon some global state, so `loading_onGameInit`
  // can only be called once. Fail hard here if this isn't the first time
  // `loading_onGameInit` has been called.
  assert(window == NULL && texture == NULL &&
         "`window` or `texture` were not NULL, was `loading_onGameInit` called "
         "twice?");

  // Setup SDL window and renderer
  SDL_Renderer *renderer;
  SDL_CreateWindowAndRenderer(width, height, SDL_WINDOW_SHOWN, &window,
                              &renderer);
  SDL_SetWindowTitle(window, "DOOM");

  // Doom Frame buffer pixels are 32-bit values with their 8-bit color
  // components logically ordered "ARGB", but this 32-bit value is stored in
  // little-endian order (because WebAssembly always orders multi-byte values in
  // a little-endian way), so the order of the bytes is reversed and is actually
  // "BGRA".

  // Helpfully, SDL supports a pixel format that exactly matches how Doom lays
  // out the pixels in its framebuffer: either SDL_PIXELFORMAT_XRGB8888 or
  // SDL_PIXELFORMAT_BGRX8888, dependant on whether SDL itself is running on a
  // little-endian platform (i.e. matching WebAssembly) or big endian platform
  // (i.e. opposite WebAssembly), respectively.
  Uint32 pixelFormat = running_on_little_endian() ? SDL_PIXELFORMAT_XRGB8888
                                                  : SDL_PIXELFORMAT_BGRX8888;
  texture = SDL_CreateTexture(renderer, pixelFormat, SDL_TEXTUREACCESS_TARGET,
                              width, height);
}

/*
 * Report size information about the WAD data that Doom should load
 *
 * This information provided by this function allows Doom to prepare the space
 * in memory needed to then call `loading_readWads` to receive the data in all
 * WADs that are to be loaded by Doom.
 *
 * This function communicates this information to Doom:
 *  `int32_t numberOfWads`
 *    - the number of WAD files that should be loaded
 *  `int32_t numberOfTotalBytesInAllWads`
 *    - the total length, in bytes, of all WAD files combined
 *
 * This function communicates these details by writing related `int32_t` values,
 * in little-endian order, to the memory exported by the Doom WebAssembly
 * module.
 *
 * The `int32_t` value stored in the memory locations for `numberOfWads` before
 * this function is called is 0. The value for `numberOfWads` still being 0 when
 * this function returns communicates to Doom "No custom WAD data to load;
 * please load the Doom shareware WAD instead".
 *
 * In other words, this function is allowed to do nothing and that will result
 * in `loading_readWads` NOT being called and the Doom Shareware WAD being
 * loaded into Doom.
 *
 * args:
 *  context:
 *    - allows interaction with Doom WebAssembly module exports
 *  numberOfWadsOffset:
 *    - byte index into Doom exported memory where the value `int32_t
 *      numberOfWads` should be written in little-endian order
 *  numberOfTotalBytesInAllWadsOffset:
 *    - byte index into Doom exported memory where the value `int32_t
 *      numberOfTotalBytesInAllWads` should be written in little-endian order
 *
 * Implements Doom import: function loading.wadSizes(i32, i32) -> ()
 */
void loading_wadSizes(doom_module_context_t *context,
                      int32_t numberOfWadsOffset,
                      int32_t numberOfTotalBytesInAllWadsOffset) {
  // We're just going to assume that the sum of the sizes in bytes of all WADs
  // never exceeds 2GB, and so this sum can fit into a signed 32-bit int.
  // Therefore we'll never be checking for overflow.
  int32_t numberOfTotalBytesInAllWads = 0;
  doom_module_config_t *config = doom_module_context_config(context);
  for (int i = 0; i < config->numberOfWadFiles; i++) {
    FILE *file = fopen(config->pathsToWadFiles[i], "rb");
    assert(file != NULL && "Failed to open a WAD file");
    fseek(file, 0L, SEEK_END);
    size_t file_size = ftell(file);
    fclose(file);

    numberOfTotalBytesInAllWads += file_size;
  }

  memory_reference_t *mem_ref = memory_reference_new(context);

  write_i32_to_wasm_memory(memory_reference_data(mem_ref) + numberOfWadsOffset,
                           config->numberOfWadFiles);
  write_i32_to_wasm_memory(memory_reference_data(mem_ref) +
                               numberOfTotalBytesInAllWadsOffset,
                           numberOfTotalBytesInAllWads);

  memory_reference_delete(mem_ref);
}

/*
 * Copy, to memory exported by the Doom WebAssembly module, the data for all WAD
 * files that Doom should load, and the byte length of each WAD file
 *
 * To understand how this function operates, consider that this function is
 * called immediately after a call to `loading_wadSizes`, and the result of
 * calling `loading_wadSizes` is that two int32_t values have been written to
 * memory:
 *  `int32_t numberOfWads`
 *    - the number of WAD files that should be loaded
 *  `int32_t numberOfTotalBytesInAllWads`
 *    - the total length, in bytes, of all WAD files combined
 *
 * This function is only called if the `numberOfWads` value after the call to
 * `loading_wadSizes` is greater than 0.
 *
 * args:
 *  context:
 *    - allows interaction with Doom WebAssembly module exports
 *  wadDataDestinationOffset:
 *    - bytes index into Doom exported memory where the data for all WAD files
 *      should be written, end-to-end. The order that the WADs are written here
 *      determines the order in which Doom loads them. The number of bytes
 *      available to write to at `wadDataDestinationOffset` is exactly
 *      `numberOfTotalBytesInAllWads`, and this function is expected to write
 *      exactly that number of bytes.
 *  byteLengthOfEachWadOffset:
 *    - bytes index into Doom exported memory where an array of `int32_t` with
 *      length `numberOfWads` exists. To this array should be written exactly
 *      `numberOfWads` `int32_t` values, in little-endian fashion, each which is
 *      the byte length of the respective WAD file.
 *
 * Implements Doom import: function loading.readWads(i32, i32) -> ()
 */
void loading_readWads(doom_module_context_t *context,
                      int32_t wadDataDestinationOffset,
                      int32_t byteLengthOfEachWadOffset) {
  memory_reference_t *mem_ref = memory_reference_new(context);

  uint8_t *dataDest = memory_reference_data(mem_ref) + wadDataDestinationOffset;
  uint8_t *byteLengthDest =
      memory_reference_data(mem_ref) + byteLengthOfEachWadOffset;

  doom_module_config_t *config = doom_module_context_config(context);
  for (int i = 0; i < config->numberOfWadFiles; i++) {
    FILE *file = fopen(config->pathsToWadFiles[i], "rb");
    assert(file != NULL && "Failed to open a WAD file");
    fseek(file, 0L, SEEK_END);
    size_t file_size = ftell(file);
    fseek(file, 0L, SEEK_SET);
    size_t numRead = fread(dataDest, file_size, 1, file);
    assert(numRead == 1 && "Failed to successfully read a WAD file");
    fclose(file);

    write_i32_to_wasm_memory(byteLengthDest, file_size);

    dataDest += file_size;
    byteLengthDest += 4;
  }

  memory_reference_delete(mem_ref);
}

/*
 * Provide a representation of the current 'time', in milliseconds
 *
 * This function may never return a value that is smaller than a value it
 * previously returned, but that's the only requirement on how this function is
 * implemented.
 *
 * This function controls how time passes in Doom. A natural implementation of
 * this function would return the number of milliseconds that have passed since
 * some fixed moment in time.
 *
 * args:
 *  context:
 *    - allows interaction with Doom WebAssembly module exports
 *
 * returns:
 *  a value representing the current time, in milliseconds
 *
 * Implements Doom import: function runtimeControl.timeInMilliseconds() -> (i64)
 */
int64_t runtimeControl_timeInMilliseconds(doom_module_context_t *context) {
  return SDL_GetTicks64();
}

/*
 * Respond to a new frame of the Doom game being available
 *
 * args:
 *  context:
 *    - allows interaction with Doom WebAssembly module exports
 *  screenBufferOffset:
 *    - byte index into Doom exported memory where the bytes/pixels of the
 *      screen buffer reside.
 *      - The screen buffer is exactly `width`*`height` int32_t pixels
 *        contiguous in memory, where `width` and `height` were the values
 *        passed perviously to `loading_onGameInit`
 *      - The pixels are ordered row major, from top-left pixel (index 0) to
 *        bottom-right (index `width`*`height`)
 *      - The color data in each 32-bit pixel is made up of four 8-bit color
 *        components packed in the order BGRA (i.e. Blue, Green, Red, Alpha),
 *        from low/first byte to high/last byte when the `int32_t` pixel is seen
 *        as an array of 4 bytes.
 *
 * Implements Doom import: function ui.drawFrame(i32) -> ()
 */
void ui_drawFrame(doom_module_context_t *context, int32_t screenBufferOffset) {
  int textureWidth;
  SDL_QueryTexture(texture, NULL, NULL, &textureWidth, NULL);

  memory_reference_t *mem_ref = memory_reference_new(context);
  SDL_UpdateTexture(texture, NULL,
                    memory_reference_data(mem_ref) + screenBufferOffset,
                    textureWidth * sizeof(uint32_t));
  memory_reference_delete(mem_ref);

  SDL_Renderer *renderer = SDL_GetRenderer(window);
  SDL_RenderClear(renderer);
  SDL_RenderCopy(renderer, texture, NULL, NULL);
  SDL_RenderPresent(renderer);
}

/*
 * Report the size, in bytes, of a specific save game
 *
 * args:
 *  context:
 *    - allows interaction with Doom WebAssembly module exports
 *  gameSaveId:
 *    - identifies a specific save game
 *
 * returns:
 *  Number of bytes in the associated save game data. Returns 0 if no save game
 * data exists for this `gameSaveId`.
 *
 * Implements Doom import: function gameSaving.sizeOfSaveGame(i32) -> (i32)
 */
int32_t gameSaving_sizeOfSaveGame(doom_module_context_t *context,
                                  int32_t gameSaveId) {
  FILE *file = fopen_saveGame(gameSaveId, "rb");
  if (file == NULL) {
    return 0;
  } else {
    fseek(file, 0L, SEEK_END);
    size_t file_size = ftell(file);
    fclose(file);
    return file_size;
  }
}

/*
 * Copy, to memory exported by the Doom WebAssembly module, the data for a
 * specific save game
 *
 * args:
 *  context:
 *    - allows interaction with Doom WebAssembly module exports
 *  gameSaveId:
 *    - id associated with the save game
 *    - saved games are identified completely by this number
 *  dataDestinationOffset:
 *    - byte index into Doom exported memory where the bytes of the save game
 *      should be copied. It's guaranteed that at least `X` bytes are reserved
 *      in memory to hold this save game data, where `X` is the value last
 *      returned when `gameSaving_sizeOfSaveGame` was called with the same
 *      `gameSaveId`.
 *
 * returns:
 *  Number of bytes of data game data actually copied.
 *
 * Note: this function will only ever be called if `gameSaving_sizeOfSaveGame`
 * returned a non-zero value for this `gameSaveId`.
 *
 * Implements Doom import: function gameSaving.readSaveGame(i32, i32) -> (i32)
 */
int32_t gameSaving_readSaveGame(doom_module_context_t *context,
                                int32_t gameSaveId,
                                int32_t dataDestinationOffset) {
  FILE *file = fopen_saveGame(gameSaveId, "rb");
  assert(file != NULL && "Failed to open a save game file");
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  memory_reference_t *mem_ref = memory_reference_new(context);
  size_t numBytesRead =
      fread(memory_reference_data(mem_ref) + dataDestinationOffset, 1,
            file_size, file);
  memory_reference_delete(mem_ref);
  fclose(file);
  return numBytesRead;
}

/*
 * Respond to the user attempting to save their game
 *
 * args:
 *  context:
 *    - allows interaction with Doom WebAssembly module exports
 *  gameSaveId:
 *    - id associated with the save game
 *    - saved games are identified completely by this number
 *  dataOffset:
 *    - byte index into Doom exported memory where the bytes of the save game
 *      begin
 *  length:
 *    - the length, in bytes, of the save game data.
 *
 * returns:
 *  Number of bytes of data game data actually persisted
 *
 * Note: this function should return 0 in the case where saving of games isn't
 * supported.
 *
 * Implements Doom import: function gameSaving.writeSaveGame(i32, i32, i32) ->
 * (i32)
 */
int32_t gameSaving_writeSaveGame(doom_module_context_t *context,
                                 int32_t gameSaveId, int32_t dataOffset,
                                 int32_t length) {
  // Make sure the folder for saving games exists
  int mkdirResult = mkdir(SAVE_GAME_FOLDER, 0755);
  assert(mkdirResult == 0 || (mkdirResult == -1 && errno == EEXIST) &&
                                 "Failed to create the save game directory");

  FILE *file = fopen_saveGame(gameSaveId, "wb");
  assert(file != NULL && "Failed to open a save game file");
  memory_reference_t *mem_ref = memory_reference_new(context);
  size_t numBytesWritten =
      fwrite(memory_reference_data(mem_ref) + dataOffset, 1, length, file);
  memory_reference_delete(mem_ref);
  fclose(file);
  return numBytesWritten;
}

/*
 * Respond to Doom reporting a `char*` info message
 *
 * args:
 *  context:
 *    - allows interaction with Doom WebAssembly module exports
 *  messageOffset:
 *    - byte index into Doom exported memory where the first `char` of the
 *      message resides, the remaining characters of the message appear
 *      sequentially after.
 *    - the message is NOT NULL-terminated like a usual C-string.
 *  length:
 *    - length, in bytes, of the message
 *
 * Implements Doom import: function console.onInfoMessage(i32, i32) -> ()
 */
void console_onInfoMessage(doom_module_context_t *context,
                           int32_t messageOffset, int32_t length) {
  memory_reference_t *mem_ref = memory_reference_new(context);
  char *message = (char *)(memory_reference_data(mem_ref) + messageOffset);
  fprintf(stdout, "%.*s\n", length, message);
  memory_reference_delete(mem_ref);
}

/*
 * Respond to Doom reporting a `char*` info message
 *
 * args:
 *  context:
 *    - allows interaction with Doom WebAssembly module exports.
 *  messageOffset:
 *    - byte index into Doom's exported memory where the first `char` of the
 *      message resides, the remaining characters of the message appear
 *      sequentially after.
 *    - the message is NOT NULL-terminated like a usual C-string.
 *  length:
 *    - length, in bytes, of the message
 *
 * Implements Doom import: function console.onErrorMessage(i32, i32) -> ()
 */
void console_onErrorMessage(doom_module_context_t *context,
                            int32_t messageOffset, int32_t length) {
  memory_reference_t *mem_ref = memory_reference_new(context);
  char *message = (char *)(memory_reference_data(mem_ref) + messageOffset);
  fprintf(stderr, "%.*s\n", length, message);
  memory_reference_delete(mem_ref);
}
